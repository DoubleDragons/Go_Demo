// 切片
package main

import (
	"fmt"
)

func main() {

	//定义一个数组
	//	a1 := [10]int{}
	//如果不给数组赋值，那么int类型里面全部为0
	//	fmt.Println("a1=", a1) //返回数组元素全部为0

	//如果要给数组指定元素付初始值那么可以用切片。
	//除了下标为8的元素数值为5，其余全部为0
	//	a1 := [10]int{8: 5}
	//	fmt.Println("a1=", a1)

	//定义切片
	//	var s1 []int
	//	fmt.Printf("s1=%T\n", s1)

	//切片的使用
	a1 := [10]int{0, 1, 2, 3, 4, 5, 6} //没有赋值的元素全部为0
	fmt.Println("a1=", a1)

	s1 := a1[1:5] //把数组A1的下标为1，一直到数组的第5个元素取出。
	fmt.Println("s1=", s1)
	s2 := a1[4:6] //把数组A1的下标为4，一直到数组的第6个元素取出。
	fmt.Println("s2=", s2)
	//这样都是引用，如果把数组a1的下标为4的元素数值改了，那么，s1、s2里面的数值一样更改。

	//此时s1= [1 2 3 4]
	s3 := s1[2:3]
	fmt.Println("s3=", s3)
	//输出结果为：s3= [1 2 3]

	//切片有元素个数和容量属性。所谓容量，就是一次性在内存中开辟的空间，比如
	fmt.Println("s3的元素个数为：", len(s3))
	fmt.Println("s3的容量为：", cap(s3))
	//因为是引用，所以a1的元素有几个，他就有几个。当然，s3是从s1里面的数值里拿数值的，s3的容量就是从s1的指针
	//开始算起的。

	//指定切片元素个数和容量
	s4 := make([]int, 10, 20) //10就是元素个数，20就是容量。

	fmt.Println("s4的数据为：", s4)
	fmt.Println("s4的容量为：", cap(s4))

	//追加，如果追加的元素的个数和原来的元素个数之和没有超过被追加的切片的容量，那么就是在被追加的切片的元素
	//后面添加，如果超过了，那么就从新copy一个。如果被追加的切片是引用已经有的数组，那么
	//从新copy的一个是不会在引用已有数组的。
	s4 = append(s4, 234)
	fmt.Println("s4的数据为：", s4)
}
